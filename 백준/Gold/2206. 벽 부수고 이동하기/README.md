# [Gold IV] 벽 부수고 이동하기 - 2206 

[문제 링크](https://www.acmicpc.net/problem/2206) 

### 성능 요약

메모리: 215548 KB, 시간: 1184 ms

### 분류

너비 우선 탐색(bfs), 그래프 이론(graphs), 그래프 탐색(graph_traversal)

### 문제 설명

<p>N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.</p>

<p>만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.</p>

<p>한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.</p>

<p>맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.</p>

### 출력 

 <p>첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.</p>

### 풀이
- BFS 탐색을 이용하되, 벽을 뚫고 지나가는 부분을 체크해줘야 한다.
- 한 쪽에서 순차적으로 탐색: (0,0)부터 시작해서 도착지까지 탐색한다. 상,하,좌,우를 탐색하면서 도착점에 갈 때까지 벽을 부순 횟수와 해당 좌표를 방문했는지를 체크하면서 탐색한다. 여기서 메모리초과가 계속 발생했는데, 이미 방문한 좌표에 계속 방문하면서 큐에 넣다보니 큐의 크기가 무한대로 커져서 메모리 초과가 났었다!(엄청 헤멤) 해당 좌표를 방문했는지 체크해주거나, 애초에 방문기록을 저장하는 좌표를 최대 크기로 늘려서 다시 방문하지 않도록 하는 것이 핵심인듯. 이 부분을 해결해주는 것 외에 로직을 구상하는데 큰 어려움은 없었다. (추후 자세한 풀이 올릴 예정)
- 양 쪽에서 순차적으로 탐색: 다른 스터디원들은 시작점과 도착지 양 방향에서 탐색하는 방법을 사용했다. 양쪽 모두 벽을 뚫지 않고 탐색하여 거리값을 좌표에 저장해둔 후, 탐색이 끝나면 벽만 골라서 탐색한다. 이 때 벽 양쪽이 길이면 거리값을 더하고, 이렇게 더한 거리값 중 최소값을 찾아 최단거리를 찾는다. 시간적으로도 빠를 것 같고, 풀이가 명쾌해서 기억에 남는다. 이 방식으로도 다시 구현해보면 더 좋을 것 같다. 
- 풀이 노트
<img src="https://user-images.githubusercontent.com/78345851/184640479-3e6f4aaf-cca1-430c-87a7-71c07c3bf133.png"/>
